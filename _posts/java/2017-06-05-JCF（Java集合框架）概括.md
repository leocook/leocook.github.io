---
layout: post
comments: true
date: 2017-06-05
categories: java
tags: java
---

* content
{:toc}


在Java中，集合也就是可以装载多个**Java对象**的某种对象，所以Java的集合只能装载对象，在装载基础数据类型的时候，事实上装载的是基础类型锁对应的包装类。

在学习JCF之前，我们先回顾一下，在计算机编程中我们期望**集合能有哪些能力？**

- 可以遍历集合全部的元素
- 关于集合类部元素的顺序
    - 保留写入集合的顺序
    - 可根据元素的大小自动排序
- 能快速查找出集合中的某个元素
- 可以根据位置来快速的修改元素
- 能高效的增加、删除集合中元素
- 集合内的元素可以快速去重

聊到集合，那肯定少不了下面几种基础的数据结构：

- 线性存储
    - （可变）数组
    - 链表
- Hash散列表
- 平衡树




## 1.概述

在Java2.0之前，只有一些简单的集合，例如Vector/Stack/Hashtable，由于这些集合直接使用synchronized关键字来实现线程安全，使得这些集合在使用的时候效率极低。从Java2.0开始之后，Java提供了一系列的Java Collections Framework（JCF）。

![JCF](http://7xriy2.com1.z0.glb.clouddn.com/JCF.gif)

下面开始讲讲Java的集合框架（后面简称JCF）。JCF主要包括了两种类型的集合：**Collection**和**Map**。
Collection集合中的每个节点存放的是一个元素。Map集合中的每个元素存放的是<key,value>型的键值对。

## 2.Iterator接口

这是迭代器接口，不同集合的Iterator实现会不一样。例如ArrayList的Iterator实现是内部类Itr。
集合实现了Iterator之后，就可以使用迭代器顺序遍历了。
Iterator接口的定义如下：

```
Object next()：返回迭代器刚越过的元素的引用，返回值是Object，需要强制转换成自己需要的类型

boolean hasNext()：判断容器内是否还有可供访问的元素

void remove()：删除迭代器刚越过的元素
```

查看源码的话，会看到下面这一段代码：

```
 ......
 * @see Collection
 * @see ListIterator
 * @see Iterable
 public interface Iterator<E> {
 ......
```

- Iterable

所有实现了Iterable接口的集合，都可以使用增强的for循环，因为这个集合将会实现一个自己的Iterator。

- ListIterator

ListIterator是针对List实现的迭代器。由于List是顺序存储结构，所以除了next()、hasNext()、remove()方法，ListIterator还提供了List下标处理的相关方法，例如获取上/下一个元素以及它们的下标情况。

## 3.Collection

Collection是Java集合层次结构中的根节点，实现Collection的集合中，有的是允许存放重复的元素，有的不允许有重复的元素（set），有的集合是有序的，有的则是无序的。Collection下面有三种子接口，分别是List、Set、Queue，下面逐一介绍。

### 3.1.List

实现List接口的集合有着两大特性：允许元素重复、元素是有序的。实现了List接口的集合，可以通过位置来操作集合的元素。下图展示了List接口中的全部方法：

![List](http://7xriy2.com1.z0.glb.clouddn.com/list.png)

下面是几个常用的List类型集合。

- ArrayList

基于数组实现的线性存储集合。数组的大小可以变化，当元素个数超过了数组的大小，将会重新创建一个更大长度的数组，并把当前数组中的内容复制进去，每次长度增长为原来的1.5倍左右，可以查看源码：

```
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

- LinkedList

基于链表实现的线性存储集合。下面对比ArrayList和LinkedList：

| 操作 | ArrayList | LinkedList |
| :---: | :--- | :--- |
| 内部数据结构 | 数组 | 链表 |
| 是否顺序结构 | 是 | 是 |
| 位置检索 | 快 | 慢 |
| 增、删 | 慢 | 快 |



### 3.2.Set

实现Set接口的集合内部元素不重复，Set有三个具体的实现类：HashSet（散列集）、LinkedHashSet（顺序集）、TreeSet（平衡树）。

- HashSet

基于hash的无序set。其实HashSet内部是用HashMap实现的，HashMap后边会说到。在散列集中，有两个名词需要关注，初始容量和客座率。客座率是确定在增加规则集之前，该规则集的饱满程度，当元素个数超过了容量与客座率的乘积时，容量就会自动翻倍。

- LinkedHashSet

基于链表实现的HashSet，LinkedHashSet中的元素是有序的，且顺序和写入的顺序一致。

- TreeSet

TreeSet是一个有序的Set，排序的比较器可以通过传入Comparator来自定义。

### 3.3.Queue

队列是一种FIFO（First in first out）数据结构，元素在Queue的末尾添加，在头部删除。
![Queue](http://7xriy2.com1.z0.glb.clouddn.com/Queue.png)
Queue接口分别定义了上面6个方法，分别有插入、移除和检查的功能，有的方法在某些特殊情况下回报错，有的则不会，具体见下表：

| Operation | 抛出异常 | 返回特殊值 | 操作失败的条件 |
| :---: | :--- | :--- | :--- |
| Insert（插入） | add(e) | offer(e),return false | 当队列空间有限制，且没有多余的空间时 |
| Remove（移除） | remove() | poll(),return null | 队列为空 |
| Examine（检查） | element() | peek(),return null | 队列为空 |

Queue平时用的不是很多，优先队列PriorityQueue有的时候会用到。

## 4.Map

Map是存储键值对映射（key,value）的容器类，可以存储任意类型的对象。但是key不能重复，且一个key只能对应一个值。如果使用对象作为key,那么必须要考虑一下该对象类的hashCode方法和equals方法是否需要重写，因为map是用着两个方法来判断key是否相等的，其中hashCode是用来加速判断的，如果hashCode相等，还会用equals方法来判断。

常用到的Map接口实现类，有三个：HashMap、LinkedHashMap、TreeMap。Map接口定义的方法列表可见下图：
![Map](http://7xriy2.com1.z0.glb.clouddn.com/map.png)

### 4.1.HashMap

HashMap是基于数组+链表实现的Hash散列Map结构，数组里存放着索引，链表里存放的是元素数据。(key,value)键值对中，key的hash值就是数组的下标。

在Jdk1.8中，对HashMap做了优化，当链表的长度超过8时，链表结构将会变为了平衡树，这样做主要是为了在HashMap里的元素较多时，能够加快查找的速度。



![map结构](http://7xriy2.com1.z0.glb.clouddn.com/map%20struct.png)

关于HashMap，其实有很多可以细聊的，它与很多集合都有着关系。后边会再来一篇，详细说一下Java中HashMap的设计，以及Java中散列存储的设计思想。

### 4.2.LinkedHashMap

LinkedHashMap类继承了HashMap类，HashMap中的元素是没有顺序的，但是LinkedHashMap中的元素是有顺序的。
LinkedHashMap里的元素顺序有两种排序方式：第一种是根据元素key被插入的顺序;第二种是根据元素被访问的顺序来排序（最近最少被访问的元素优先）。

### 4.3.TreeMap

TreeMap是基于红黑树结构来实现的，可以使用Comparable或Comparator接口来实现排序的比较算法。


>在日常开发中，如果不用考虑键值对元素的顺序，就使用HashMap；如果需要考虑元素插入顺序，就使用LinkedHashMap；如果需要根据Key自定义排序规则，那么就使用TreeMap。


## 5.其它集合

下面简单说几个不是很常用的集合。

### 5.1.Vector

Vector的使用和ArrayList的使用基本一样，它是线程安全的线程安全，但是Vector的线程安全是使用关键字synchronized修饰实现的，所以Vector的效率很低。相对来说，ArrayList更加高效！

### 5.2.Stack

Stack是Java2之前设计的栈结构，内部是使用数组实现的。我们知道栈结构的操作中会频繁的出现入栈和出栈，那么使用数组结构的话，在栈结构变长时，自然会带来性能上的折扣。
LinkedList也具备栈的功能，而且是基于链表实现的，所以在开发需要用到栈结构时，推荐使用LinkedList。

### 5.3.HashTable

HashTable的功能和HashMap相似，它是Dictionary类的，并且使用了synchronized关键字实现了线程安全，所以性能会很差！
除此之外，HashTable的Key不能为空指针null,但是HashMap的key可以为null。

关于集合的线程安全，后边会另写一篇详细说明。

参考地址：
http://www.open-open.com/lib/view/open1474167415464.html
http://www.cnblogs.com/CarpenterLee/p/5414253.html

## 6.总结

- JCF接口架构

![JCF接口架构](http://7xriy2.com1.z0.glb.clouddn.com/JCF.gif)

- 常用的集合分类情况

![常用的集合分类情况](http://7xriy2.com1.z0.glb.clouddn.com/jcf%E4%BD%BF%E7%94%A8.png)

- 接口功能实现

下面表格描述的比较好，每个接口对应不同数据结构的实现。

![JCF 接口实现](http://7xriy2.com1.z0.glb.clouddn.com/jcf%20imp.png)


参考文档：
http://docs.oracle.com/javase/6/docs/technotes/guides/collections/overview.html
http://www.jianshu.com/p/63e76826e852