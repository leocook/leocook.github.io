---
layout: post
comments: true
date: 2017-04-05
categories: java
tags: jvm
---

* content
{:toc}


Java开发人员无需过多考虑因指针引起的如内存泄露和溢出问题，也不用为每个new出来的对象使用delete等方法来释放内存。JVM已经为开发人员处理好了这一切，但是由于各种原因，Java程序也会出现内存溢出等问题，如果不了解JVM的内存模型以及相关的管理策略，那么整个排查过程将会变得十分艰难。
![JVM mem model](http://7xriy2.com1.z0.glb.clouddn.com/JVM%20mem%20model.png "JVM mem model")

JVM的运行时内存共有5块区域，其中有3个是线程间隔离的，有2个是线程间共享的。




## 1.程序计数器
它是线程间隔离的。字节码的行号指示器，用来标记当前线程所执行的字节码的行号。

>Q1. 为什么每个线程都需要一个独立的计数器呢？
因为JVM的多线程是轮询在CPU上执行的，任何一个时间点，一个处理器上最多只有一条指定在执行。为保证线程切换后，能恢复从正确的执行位置执行指令，所以给每个线程都独立的使用一块空间作为程序计数器，使得多线程之间计数器互不影响。

## 2.JVM栈

它是线程间隔离的，也就是常说到的“栈内存”。每个方法执行的时候都会创建一个栈桢，用来存放局部变量表用来存放该方法内使用到的局部变量表、操作数栈、动态链接、方法出口灯信息。一个方法从调用到执行完成的过程也就对应着一个栈桢在JVM栈中入栈到出栈的过程。
局部变量表中存放了编译器可确定的各种基本数据类型（例如：boolean、byte、char、short等等），以及对象的引用。

## 3.本地方法栈

它是线程间隔离的，和“JVM栈”的区别是：“JVM栈”是执行Java方法时所使用到的内存；“本地方法栈”是JVM执行Native方法时所使用到的内存存。
这一块内存在JVM规范中没有强制指定，所以不同的虚拟机实现它的方法可能不一样。Sum HotSpot虚拟机是把“JVM栈”和“本地方法栈”合二为一的。

## 4.Java堆
它是线程间共享的，存放JVM对象实例，也是GC发生的主要区域，所以也被称为GC堆。
关于GC算法垃圾回收器，后边会介绍。

## 5.方法区
它是线程间共享的，存放已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等。

### 5.1.运行时常量池
它是方法区的一部分，存放编译器生成的各种常量值。