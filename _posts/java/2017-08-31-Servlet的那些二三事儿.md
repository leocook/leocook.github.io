---
layout: post
comments: true
date: 2017-08-31
categories: java
tags: Servlet
---

* content
{:toc}


Servlet（Server Applet），全称Java Servlet。主要是使用Java来开发一些web应用，例如网站、web service等等。下面就从几个方面来总结一下servlet的关键点，当然也会提及到jsp、http等。



## servlet的生命周期

- 初始阶段  
Web容器加载servlet，调用init()方法。

- 运行阶段  
当请求到达时，运行其service()方法。service()识别请求类型，并调用相对应的doGet、doPost方法。

- 销毁阶段  
服务结束，web容器会调用servlet的distroy()方法销毁servlet。

## 如何去实现一个Servlet

先了解一下Servlet API的两个包：<code>javax.servlet.*</code>和<code>javax.servlet.http.*</code>。<code>javax.servlet.*</code>包下放的主要是一些接口，<code>javax.servlet.http.*</code>包下方的主要是上述接口在http协议中的实现。
目前网络数据交互式传输中，http协议占据这主导的地位，说不准哪天出现一个新的协议，那时servlet可能还会对新协议做支持。
实现一个Servlet目前有两种方式，一种是直接实现最底层的Servlet接口；第二种则是实现继承HttpServlet类。

### javax.servlet.Servlet接口

有下面这几个方法
- init  
在servlet初始化时，会调用它。

- service  
在servlet处理请求的时候，会调用它。

- destroy  
在服务结束时，销毁servlet的时候，会调用它。

- getServletConfig  

```
<servlet>
    <servlet-name>ServletConfigTest</servlet-name>
    <servlet-class>com.vae.servlet.ServletConfigTest</servlet-class>
    <init-param>
        <param-name>name1</param-name>
        <param-value>value1</param-value>
    </init-param>
    <init-param>
        <param-name>encode</param-name>
        <param-value>utf-8</param-value>
    </init-param>
</servlet>
```
获取servlet的配置信息,<code>init-param</code>标签下的内容。

- getServletInfo  
获取servlet信息，

### javax.servlet.http.HttpServlet类

- doGet  
处理get请求时，会执行该方法。

- doPost  
处理post请求时，会执行该方法。

- init  
在servlet初始化时，会调用它。相当于Servlet接口中的init方法。

- destroy  
在servlet初始化时，会调用它。相当于Servlet接口中的init方法。


## JSP和Servlet的关系
这里说明一下，JSP在被编译后生成的就是Servlet，所以访问jsp，其实访问的也就是其对于的Servlet。

### 四种会话作用域
由于在web开发中，数据传输的范围是不同的，所以产生了<code>四种会话作用域</code>，其实就是提供了4种生命周期的对象，用于存储数据使用。

- page  
单个页面级别
- request  
单个请求级别
- session  
单个session级别
- application  
服务器从启动到停止

### Jsp的九个内置对象

- page  
指JSP也变本身，代表的是java.lang.Object类的对象。

- request  
包含了客户端请求的信息，代表的是javax.servlet.HttpServletRequest类的对象

- session  
包含了当前会话的信息，代表的是javax.servlet.http.HttpSession类的对象。

- application  
包含了当前服务器全局的信息，重启后失效。代表的是javax.servlet.ServletContext类的对象。

- response  
包含了服务端返回客户端的响应信息，代表的是javax.servlet.HttpServletResponse类的对象。

- out  
向客户端输出数据。

- config  
ServletConfig类的一个实例，

- pageContext  
包含了当前页面的信息

- exception  
处理异常使用

### 内置对象和作用域的对照

| 内置对象名 | 对应的Java类 | 作用域 |
| --- | --- | --- |
| page | java.lang.Object | Page |
| request | javax.servlet.http.HttpServletRequest | Request |
| session | javax.servlet.http.HttpSession | Session |
| application | javax.servlet.ServletContext | Application |
| response | javax.servlet.http.HttpServletResponse | Page |
| out | javax.servlet.jsp.JspWriter | Page |
| config | javax.servlet.ServletConfig | Page |
| pageContext | javax.servlet.jsp.PageContext | Page |
| exception | java.lang.Throwable | Page |


## 转发和重定向

### 什么是转发和重定向
从体验上来说，转发后浏览器的URL不会变，而重定向时URL会变。从执行的原理上来说，转发是服务端的行为，期间request域共享；重定向是客户端的行为，客户端发现返回的http状态码是302时，将会向新的URL发送

### Servlet中如何实现转发和重定向

- 转发  
request.getRequestDispatcher(“目标文件”).forward(request,response)

- 重定向  
response.sendRedirect(“目标文件”)

### JSP中如何实现转发和重定向
- 转发  
<code> &lt;jsp:forward page="目标文件" /&gt; </code>

- 重定向  
<code>&lt;%response.sendRedirect("目标文件");//重定向到new.jsp%&gt;</code>

### 如何选择转发和重定向

- 何时选择转发  
  - 当需要隐藏地址的时候，选用转发；
  - 当需要共享request域数据时，选用转发。

- 何时选择重定向  
当不需要隐藏地址的时候，且不需要共享request域数据时，选用重定向。重定向只是单纯的重新访问一个新的地址。

## Servlet中的过滤器

### 为什么需要过滤器
在web开发中，我们可能需要对所有的请求都做一层过滤，例如权限验证这些操作等等。此时我们就需要一种技术，所有或者一类请求在处理前都会经过这个技术来进行一次预处理。

### 什么是过滤器
过滤器就是在请求到达Servlet之前会经过的一层，在过滤器这一层我们可以检查权限、可以对所有或者部分请求做统一的处理。

### 如何使用过滤器
过滤器类一般都会实现<code>javax.servlet.Filter</code>这个接口。然后在web.xml中进行配置，下面是一个例子：

```
<filter>
    <filter-name>filter01</filter-name> <!-- filter的名字，自定义 -->
    <filter-class>filter.class</filter-class> <!-- filter类，可以是自己实现的，也可以使用默认的 -->
    <init-param>
        <param-name>key</param-name><!-- 初始化参数，可选配置 -->
        <param-value>value</param-value>
    </init-param>
</filter>
<filter-mapping> <!-- 配置filter生效的url，当访问这些url时，都会执行该filter -->
    <filter-name>filter01</filter-name> <!-- filter的名字，自定义 -->
    <url-pattern>/*</url-pattern> <!-- 这里可以精确匹配，也可以模糊匹配，例如匹配所有的url就是“/*”，匹配所有的jsp，就是“*.jsp”.注意，路径和扩展名匹配不可以同时使用 -->
</filter-mapping>
```

### 过滤器链


## Servlet中的监听器

Servlet的监听器是实现了javax.servlet.ServletContextListener接口的服务端程序，它随web的启动而启动，在启动期间可以监听web应用内部发生的一系列事件。可以对不同域的不同事件设置监听，例如域内部属性的变化，request、session和application的创建和销毁等等。

### 官方提供的几个监听器

Servlet监听器对特定的事件进行监听，当产生这些事件的时候，会执行监听器的代码。可以对应用的加载、卸载，对session的初始化、销毁，对session中值变化等事件进行监听。官方提供了一些对ServletContext、session、request的监听。

### Session级别的监听
#### HttpSessionListener
全局监听session的创建和销毁，在XML中配置监听，全局的。
- sessionCreated  
有新的session创建时，会出发执行这个方法
- sessionDestroyed  
执行session.invalidate()方法时，或者session超时（默认30分钟）会执行该方法。

#### HttpSessionBindingListener
实例化后设置为session的属性，绑定到单个session。只能监听单个session，一个session对应一个HttpSessionBindingListener对象的实例。
- valueBound  
当对象被绑定到session上时，例如：application.setAttribute("onlineUserList", onlineUserList);
- valueUnbound  
执行方法session.invalidate()；或者session超时；或者修改了session域的属性，例如：session.setAttribute("onlineUserListener", "其他对象");或者删除了某一个属性，例如：session.removeAttribute("onlineUserListener")。都会触发valueUnbound方法的执行。

#### HttpSessionAttributeListener
监听session的属性变化
- attributeAdded  
当有新的属性添加时，将会将会触发
- attributeRemoved  
当有属性移除时，将会触发
- attributeReplaced  
当有属性被覆盖时，将会触发

#### HttpSessionActivationListener
和HttpSessionBindingListener一样，需要绑定到session上，是对单个session的监听。有的时候需要对session做持久化，即将session持久化写到磁盘上，当服务器挂了重启后，还能恢复session中的信息。
- sessionWillPassivate  
当执行这个方法的时候，可以把session保存到硬盘上
- sessionDidActivate  
当执行这个方法的时候，就是把session从硬盘读取出来，并使用

### ServletContext级别的监听
#### ServletContextAttributeListener
ServletContext上存在属性变化时，将会出发此类监听。
- attributeAdded  
ServletContext上添加属性时触发。
- attributeRemoved  
ServletContext上删除属性时触发。
- attributeReplaced  
ServletContext上添加属性值被修改时触发。

#### ServletContextListener
监听ServletContext的创建和销毁
- contextInitialized  
初始化ServletContext对象
- contextDestroyed  
销毁ServletContext对象

### request级别的监听
#### ServletRequestAttributeListener
监听request属性变化事件
- attributeAdded  
当request域有新的属性添加时，触发事件
- attributeRemoved  
当request域有属性移除时，触发事件
- attributeReplaced  
当request域有属性被覆盖时，触发事件

#### ServletRequestListener
监听request生命周期的变化
- requestDestroyed  
当request销毁时，触发该事件
- requestInitialized  
当request初始化时，触发该事件

## servlet的单例与多线程问题
servlet是单例，多线程的。servlet类在web容器中只会被创建一个实例。但是多线程环境下，多个线程可以同时调用同一个Servlet的service方法。
所以在Servlet对象中使用共享变量的时候要小心，很容易出现线程安全问题。

## servlet的单线程模式
默认Jsp的Servlet是单例、多线程的。但也可以在Jsp页面里声明<code> <%@page isThreadSafe="false"%> </code>，表示Jsp的Servlet类将以Singleton模式来运行。即：Jsp对应的Servlet实例将不会同时被多个线程调用，一个请求创建一个Servlet实例。
> Jsp的Servlet里一般不会有很复杂的业务逻辑，更多的是页面展示，以及一些简单的数据处理，所以一般情况下不用配置<code>isThreadSafe=false</code>的，推荐配置为true.
