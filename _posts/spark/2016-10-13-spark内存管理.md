---
layout: post
comments: true
date: 2016-10-13
categories: spark
tags: spark
---

* content
{:toc}

Spark的最大卖点就是内存迭代运算，相对于传统MapReduce的磁盘迭代运算，spark的迭代运算要快得多。作为内存迭代运算的spark，掌握它的内存管理是很有必要的。

Spark的内存可以大体上分为三大块：Reserved Memory（预留内存）、User Memory（用户内存），以及Spark Memory（Spark内存）。Spark Memory又包含Storage Memory和Execution Memory这两大块，1.6版本之前他们是不能共享的，从1.6版本(如下图)开始它们就可以共享了。**而本文介绍的就是1.6版本开始之后内存管理机制。**

![spark mem](http://leocook-blog.test.upcdn.net/spark%20m.png "spark mem")



本文在描述spark各个部分内存的时候，大概从三个方面介绍：概念描述、该内存参数怎么配置，内存不够的时候会发生什么情况。

## 1.Reserved Memory

系统预留内存，用于存储Spark内部对象。它的大小是300MB，不能通过参数修改，如果真的需要修改，需要重新编译（spark.testing.reservedMemory参数可以使用，但是不推荐在线上环境中使用）。

当executor分配的内存小于1.5*Reserved Memory的时候，将会报“please use larger heap size”错误。

## 2.User Memory

用户内存，用于存储RDD转换操作所需要的数据，例如RDD依赖等信息。
这个内存大小为(“Java Heap” – “Reserved Memory”) * (1.0 – spark.memory.fraction)，默认是(“Java Heap” – 300MB) * 0.25。如果用户使用的内存大于这个值，将会导致OOM。

## 3.Spark Memory

这部分内存是归Spark自身管理的，大小为(“Java Heap” – “Reserved Memory”) * spark.memory.fraction，默认为(“Java Heap” – 300MB) * 0.75。Spark Memory又被分为Storage Memory和Execution Memory，下面详细说明。


### 3.1.Storage Memory

用来存储spark的cache数据，例如RDD的缓存、unroll数据。当缓存数据的持久化level达到一定的时候，spark将会把它存到磁盘中，例如广播变量的数据持久化级别都是“MEMORY_AND_DISK”，所以所有的广播变量数据大小达到一定量的时候，都会存到磁盘中的。默认大小是Spark Memory的0.5，可用过参数spark.memory.storageFraction来配置（spark.memory.storageFraction=0.5）。

- Unroll Memory

"Unroll Memory"是"Storage Memory"的一部分，在Spark中数据可以以序列化和反序列化的形式存储，序列化后的数据是无法直接被访问的，只有反序列化后才能被使用，反序列化过程中用到的RAM就是Unroll Memory。Spark中的大部分数据都是以序列化的形式传输的。


### 3.2.Execution Memory

用于存储spark的buffer部分，例如task运行过程中产生的一些对象，shuffle过程中map的输出，在内存不够的时候，支持写到磁盘上。Spark Memory中能被应用使用的内存中，除了Storage Memory剩余内存都是Execution Memory的了。

- Shuffle Memory

shuffle阶段使用的内存，主要是使用在sort上。如果这一块没有足够的内存来用作shuffle，将会内存溢出失败。
当然，在内存不足的时候，也可以使用spark的外部排序（spark.shuffle.spill=true），但是性能将会有些折扣。



### 3.3.Storage Memory和Execution Memory共享规则

- **一方空闲，一方内存不足的时候，内存不足的一方可以借用另一方的内存。**

- **Storage Memory占用了Execution Memory的内存，当Execution Memory内存不够用时**

强制释放Storage Memory中属于Execution Memory的那部分内存，释放后的内存被Execution Memory使用。Storage Memory丢失的数据在下次使用的时候会被重新计算。

- **Execution Memory占用了Storage Memory的内存，当Storage Memory内存不够用时**

不强制释放Execution Memory中属于Storage Memory的那部分内存，Storage Memory会一直等待，直到Execution Memory主动释放属于Storage Memory的那部分内存。因为强制释放Execution Memory会导致任务失败。

（PS：感觉Execution Memory在欺负Storage Memory，有木有~~~）




